use anyhow::Result;
use std::fs;
use std::io::{BufRead, BufReader, Write};
use std::path::Path;

use crate::models::Feature;

const SECTION_START: &str = "# ==== GENERATED BY FEATURES-CLI ====";
const SECTION_END: &str = "# ==== END SECTION GENERATED BY FEATURES-CLI ====";

/// Generate or update a CODEOWNERS file with feature ownership information.
///
/// # Arguments
///
/// * `features` - List of features to generate CODEOWNERS entries for
/// * `base_path` - Base path of the project (where features are located)
/// * `project_dir` - Optional project directory to calculate relative paths
/// * `output_dir` - Directory where the CODEOWNERS file should be created
///
/// # Behavior
///
/// - Creates CODEOWNERS if it doesn't exist
/// - Updates existing CODEOWNERS while preserving custom content
/// - Generated content is placed between section markers
/// - Content outside markers is preserved
/// - Paths are normalized with forward slashes and leading `/`
/// - Owners automatically get `@` prefix if not present
pub fn generate_codeowners(
    features: &[Feature],
    base_path: &Path,
    project_dir: Option<&Path>,
    output_dir: &Path,
) -> Result<()> {
    let codeowners_path = output_dir.join("CODEOWNERS");

    // Read existing file content if it exists
    let (before_section, after_section) = if codeowners_path.exists() {
        read_existing_codeowners(&codeowners_path)?
    } else {
        (String::new(), String::new())
    };

    // Generate the CODEOWNERS entries
    let mut entries = Vec::new();
    collect_entries(features, base_path, project_dir, &mut entries);

    // Write the CODEOWNERS file
    write_codeowners_file(&codeowners_path, &before_section, &entries, &after_section)?;

    eprintln!(
        "âœ… CODEOWNERS file generated at: {}",
        codeowners_path.display()
    );
    Ok(())
}

/// Read an existing CODEOWNERS file and extract content before and after the generated section
fn read_existing_codeowners(codeowners_path: &Path) -> Result<(String, String)> {
    let file = fs::File::open(codeowners_path)?;
    let reader = BufReader::new(file);
    let mut lines = Vec::new();

    for line in reader.lines() {
        lines.push(line?);
    }

    // Find the section markers
    let start_idx = lines.iter().position(|l| l.trim() == SECTION_START);
    let end_idx = lines.iter().position(|l| l.trim() == SECTION_END);

    match (start_idx, end_idx) {
        (Some(start), Some(end)) if start < end => {
            // Extract content before and after the generated section
            let before = lines[..start].join("\n");
            let after = if end + 1 < lines.len() {
                lines[end + 1..].join("\n")
            } else {
                String::new()
            };
            Ok((before, after))
        }
        _ => {
            // No valid section found, keep all content as "before"
            Ok((lines.join("\n"), String::new()))
        }
    }
}

/// Recursively collect CODEOWNERS entries from features
fn collect_entries(
    features: &[Feature],
    base_path: &Path,
    project_dir: Option<&Path>,
    entries: &mut Vec<String>,
) {
    for feature in features {
        // Calculate the path for CODEOWNERS
        let feature_path = std::path::PathBuf::from(&feature.path);
        let full_path = base_path.join(&feature_path);

        // Determine the final path to write
        let codeowners_path = if let Some(proj_dir) = project_dir {
            // Remove project_dir from the full_path if present
            if let Ok(relative) = full_path.strip_prefix(proj_dir) {
                relative.to_path_buf()
            } else {
                full_path
            }
        } else {
            full_path
        };

        // Convert to forward slashes and add leading slash for CODEOWNERS format
        let path_str = codeowners_path.to_str().unwrap_or("").replace('\\', "/");

        let path_str = if path_str.starts_with('/') {
            path_str
        } else {
            format!("/{}", path_str)
        };

        // Add owner with @ prefix, but skip if owner is empty
        if feature.owner.is_empty() {
            entries.push(format!("{} @Unknown", path_str));
        } else {
            let owner = format_owner(&feature.owner);
            entries.push(format!("{} {}", path_str, owner));
        }

        // Recursively collect from nested features
        collect_entries(&feature.features, base_path, project_dir, entries);
    }
}

/// Format owner with @ prefix if not already present
fn format_owner(owner: &str) -> String {
    if owner.starts_with('@') {
        owner.to_string()
    } else {
        format!("@{}", owner)
    }
}

/// Write the CODEOWNERS file with preserved content and generated section
fn write_codeowners_file(
    codeowners_path: &Path,
    before_section: &str,
    entries: &[String],
    after_section: &str,
) -> Result<()> {
    let mut file = fs::File::create(codeowners_path)?;

    // Write content before the generated section
    if !before_section.is_empty() {
        writeln!(file, "{}", before_section)?;
        if !before_section.ends_with('\n') {
            writeln!(file)?;
        }
    }

    // Write the generated section
    writeln!(file, "{}", SECTION_START)?;
    for entry in entries {
        writeln!(file, "{}", entry)?;
    }
    writeln!(file, "{}", SECTION_END)?;

    // Write content after the generated section
    if !after_section.is_empty() {
        if !after_section.starts_with('\n') {
            writeln!(file)?;
        }
        write!(file, "{}", after_section)?;
        if !after_section.ends_with('\n') {
            writeln!(file)?;
        }
    }

    Ok(())
}
